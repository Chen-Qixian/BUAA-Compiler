program pl0(input,output,fin) ;  
{ 程序名称:pl0 , 待编译源代码文件为 ？fin ，input，output 干啥的？}
{ 版本号：version 1.0 oct.1989 }
{ PL/0 compiler with code generation 有代码生成器的PL/0编译器}
const norw = 13;          { no. of reserved words 保留字数量}
      txmax = 100;        { length of identifier table 符号表长度}
      nmax = 14;          { max. no. of digits in numbers 最大数字位数}
      al = 10;            { length of identifiers 标识符长度}
      amax = 2047;        { maximum address 最大地址}
      levmax = 3;         { maximum depth of block nesting 最大嵌套块深度}
      cxmax = 200;        { size of code array 代码数组大小}
                          { 啥是code array ? 生成的p-code代码数组}
type symbol = { 类型定义 }
     ( nul,ident,number,plus,minus,times,slash,oddsym,eql,neq,lss,
       leq,gtr,geq,lparen,rparen,comma,semicolon,period,becomes,
       beginsym,endsym,ifsym,thensym,whilesym,dosym,callsym,constsym,
       varsym,procsym,readsym,writesym );
     { ？ type symbol 是干啥的 ？ 返回的符号值的集合 }
     alfa = packed array[1..al] of char;
     { 用alfa表示标识符类型 ， 最大长度为al，即标识符最大长度 }
     objecttyp = (constant,variable,prosedure);
     { 分程序类型：包括常量说明、变量说明和过程说明 }
     symset = set of symbol;
     { 符号集类型 }
     fct = ( lit,opr,lod,sto,cal,int,jmp,jpc,red,wrt ); 
     { functions 指令码类型（助记符） }
     instruction = packed record         { p-code 指令类型定义 }
                     f : fct;            { function code 指令码 （助记符）}
                     l : 0..levmax;      { level （语句块层数差）}
                     a : 0..amax;        { displacement address（地址偏移量/数据值） }
                   end;
                  {   lit 0, a : load constant a
                      opr 0, a : execute operation a
                      lod l, a : load variable l,a
                      sto l, a : store variable l,a
                      cal l, a : call procedure a at level l
                      int 0, a : increment t-register by a
                      jmp 0, a : jump to a
                      jpc 0, a : jump conditional to a
                      red l, a : read variable l,a
                      wrt 0, 0 : write stack-top
                  }

{ 全局变量声明部分（PL/0文法不传引用 ，通过全局变量修改）}
var   ch : char;      { last character read 预读1个字符 }
      sym: symbol;    { last symbol read 预读1个符号 }
      id : alfa;      { last identifier read 上一个读到的标识符 }
      num: integer;   { last number read 上一个读到的数字 }
      cc : integer;   { character count 读到的字母个数 }
      ll : integer;   { ？line length 行数 }
      kk,err: integer;
      { err：错误处理调用次数（记录当前出错总数）kk : 当前读到标识符的长度 }
      cx : integer;   { ？ code allocation index 已生成代码的下标 }
      line: array[1..81] of char; { 读当前行代码 }
      a : alfa;       { 一个标识符类型 }
      code : array[0..cxmax] of instruction; 
      { 生成的目标p-code指令数组 ，最大长度200 }
      word : array[1..norw] of alfa; 
      { 保留字数组 ，标识符类型，最大长度 13 }
      wsym : array[1..norw] of symbol;
      { 保留字数组 ，符号类型，最大长度 13 }
      ssym : array[char] of symbol;
      { ？ array[char] 是什么用法 ？ }
      mnemonic : array[fct] of
                   packed array[1..5] of char;
      declbegsys, statbegsys, facbegsys : symset;
      table : array[0..txmax] of   { table是符号表 }
                record             { record中的内容可以类似struct中的属性调用 }
                  name : alfa;     { 符号表中元素名称 }
                  case kind: objecttyp of     { 符号表中元素种类：常量变量过程定义 }
                    constant : (val:integer );
                    variable,prosedure: (level,adr: integer )
                end;
      fin : text;     { 源程序文件（PL0文法源代码内容） }
      sfile: string;  { 源程序文件名 }

{ 出错处理子程序 }
procedure error( n : integer ); { ? 传入参数 n 是啥意思 ？ } 
  begin
    writeln( '****', ' ':cc-1, '^', n:2 );
    { 出错处理输出语句 ，输出cc - 1个空格 ，^ ，n占两位 }
    err := err+1 { 错误个数++ }
  end; { error }

{ 读符号子程序 } 
procedure getsym;  
  var i,j,k : integer;
  { 读下一字符子程序 }
  procedure getch; 
  { 该子程序当读完一整行代码后 ，会读入下一个整行 ，每个字符从整行数组中取出 }
    begin
      if cc = ll  { get character to end of line }
      { 当读入字符总数等于行长度的时候即读到行尾 }
      then begin { read next line 读完一行后即开始读下一行 }
             if eof(fin)
             { 判断读到代码文件尾 ，则程序不完整，报错，退出程序 }
             then begin
                    writeln('program incomplete');
                    close(fin);
                    exit;
                  end;
             ll := 0; { 初始化行下标为0 }
             cc := 0; { 初始化已读字符数为0 }
             write(cx:4,' '); 
             { 打印4位地址长度 }
             while not eoln(fin) do { 没到行尾之前循环 }
               begin
                 ll := ll+1;   { 行下标 ++ }
                 read(fin,ch); { 从源代码文件中读取一个字符 }
                 write(ch);    { 输出读到的字符进行检查 }
                 line[ll] := ch{ 将该字符存入行数组中 }
               end;
             writeln;          { 输出换行 }
             readln(fin);      { 从fin读一行 }
             ll := ll+1;       { 行下标 ++ }
             line[ll] := ' ' { process end-line 行内容尾端以空格结束 }
           end;
      cc := cc+1;  { 读取字符数 ++ }
      ch := line[cc] { 从整行代码中读取一个字符 }
    end; { getch 结束 }
  begin { procedure getsym;  读符号子程序开始 }
    while ch = ' ' do 
      getch;        { 跳过指定的空行 }
    if ch in ['a'..'z']         { 下一字符是字母 }
    then begin  { identifier of reserved word 检查是否保留字 }
           k := 0;
           repeat        { 循环终止条件为读到字符非alnum }
             if k < al   { 小于标识符长度 } 
             then begin
                    k := k+1;  
                    a[k] := ch  { 该字符加入到当前的符号数组a中 }
                  end;
             getch        { 继续读符号 }
           until not( ch in ['a'..'z','0'..'9']);
           if k >= kk     { kk : last identifier length 当前读到标识符的长度 }
           then kk := k
           else repeat    { 该循环将读到的符号用空格补充长度至k }
                  a[kk] := ' ';
                  kk := kk-1
                until kk = k;
           id := a;  { 保存刚刚读到的标识符到id }
           i := 1;   { 二分查找左端i 右端j }
           j := norw;   { binary search reserved word table }
           { 以下开始二分查找保留字表 }
           repeat
             k := (i+j) div 2;
             if id <= word[k]  { 该word表在main中初始化 }
             then j := k-1;
             if id >= word[k]  { 这个字符串大小比较应该是按照字典序 }
             then i := k+1
           until i > j;
           if i-1 > j          { 根据查找后的结果判断该符号是保留字还是标识符 }
           then sym := wsym[k] { 赋值 }
           else sym := ident
         end
    else if ch in ['0'..'9']   { 数字值 }
         then begin  { number }
                k := 0;
                num := 0;
                sym := number;
                repeat { 将字符串的数值转成数字 }
                  num := 10*num+(ord(ch)-ord('0'));
                  k := k+1;
                  getch
                until not( ch in ['0'..'9']);
                if k > nmax { 超过数字长度限制调用出错处理 }
                then error(30) { 出错码30 }
              end
         else if ch = ':' { 读到 : 需要再读一个字符判断是否为赋值 }
              then begin
                     getch;
                     if ch = '='
                     then begin
                            sym := becomes; { 是赋值符号 }
                            getch
                          end
                     else sym := nul { 否则是空 }
                   end
              else if ch = '<' { 如果读到< }
                   then begin
                          getch;
                          if ch = '='
                          then begin
                                 sym := leq; { <= }
                                 getch
                               end
                          else if ch = '>'   { <> }
                               then begin
                                      sym := neq;
                                      getch
                                    end
                               else sym := lss { < }
                        end
                   else if ch = '>' { 读到 > }
                        then begin
                               getch;
                               if ch = '=' { >= }
                               then begin
                                      sym := geq;
                                      getch
                                    end
                               else sym := gtr { > }
                             end
                        else begin
                               sym := ssym[ch];
                               getch
                             end
  end; { getsym 子程序结束 }

{ gen 子程序：生成p-code并送入目标程序区 }  
procedure gen( x: fct; y,z : integer ); 
{ 传入的参数按照指令格式：x为操作码类型，y，z为两个整形操作数，分别对应l,a }
  begin
    if cx > cxmax { 如果当前指令总数cx超出最大指令数cxmax }
    then begin
           writeln('program too long');
           close(fin);
           exit   { 源代码程序超长 退出 }
         end;
    with code[cx] do { code 是一个 instruction型数组 （类似一个字典列表）}
      begin          { 为当前code数组里指向的指令每个元素f，l，a赋值 }
        f := x;      { 即，将生成的p-code送入目标程序区 }
        l := y;
        a := z
      end;
    cx := cx+1   { 指令总数 ++ }
  end; { gen 子程序结束 }
 
{ 测试当前单词符号是否合法 } 
procedure test( s1,s2 :symset; n: integer );  
{ 传入的参数 s1为合法符号集 s2为停止符号集 n为错误码 }
  begin
    if not ( sym in s1 )           { 如果预读符号不在合法符号集内 执行报错部分 }
    then begin
           error(n);
           s1 := s1+s2;            { 扩充合法符号集 }
           while not( sym in s1) do 
             getsym                { 实现跳读 }
           end
  end; { test 子程序结束 }

{ block 分程序分析处理（块） } 
procedure block( lev,tx : integer; fsys : symset );
{ lev层深度 tx 符号表项 fsys}
  var  dx : integer;  { data allocation index 数据项下标 }
       tx0: integer;  { initial table index 符号表项下标 }
       cx0: integer;  { initial code index 代码项下标 }
  { enter 登录符号表 }
  procedure enter( k : objecttyp );  
  { k为分程序类型：包括常量说明、变量说明和过程说明 }
    begin  { enter object into table 读符号表内容 }
      tx := tx+1;        { 取下一项 }
      with table[tx] do
        begin
          name := id; { 读入的上一标识符存入name }
          kind := k;  { 传入的参数k存入kind }
          case k of
            constant : begin
                         if num > amax     
                         {? 为啥要拿上一个读入的数字和最大地址进行比较 ？ } 
                         then begin
                                error(30);   { 错误码30 这个数太大 }
                                num := 0
                              end;
                         val := num { val的定义和初始化是怎么体现的？71行？ }
                       end;
            variable : begin           { 如果k是变量声明 }
                         level := lev; { 将嵌套块深度存入层数 }
                         adr := dx;    { 数据项下标存入adr }
                         dx := dx+1    { 数据项++ }
                       end;
            prosedure: level := lev;   { 如果k是过程声明则只需存层深度 }
          end
        end
    end; { enter 子程序结束 }

  { 查找标识符在符号表中的位置 }
  function position ( id : alfa ): integer; 
  { 传入的参数id为上一个读到的符号 返回值为整数 }
    var i : integer;
    begin
      table[0].name := id;  { 符号表头名设为id }
      i := tx;              { 从tx开始向前找 }
      while table[i].name <> id do  
        i := i-1;
      position := i         { 返回值语法：如果在table中则返回i值 否则返回0 }
    end;  { position 子程序结束 }
  
  { 常量定义处理 }  
  procedure constdeclaration; 
    begin
      if sym = ident   { 如果当前符号是标识符 }
      then begin
             getsym;   { 再预读一个符号 }
             if sym in [eql,becomes]   { 若下一符号是等于/赋值 }
             then begin
                    if sym = becomes   
                    then error(1);     { 常量定义用= }
                    getsym; { 向下读一个符号（期望是数字）}
                    if sym = number    
                    then begin
                           enter(constant); { 登录常量的符号表 }
                           getsym           { 单符号先行 }
                         end
                    else error(2)
                  end
             else error(3)     { 不是=/：= 标识符后应为= }
           end
      else error(4)            { 不是标识符 const后应是标识符 }
    end; { constdeclaration 子过程结束 }
  
  { 变量声明子过程 }  
  procedure vardeclaration; 
    begin
      if sym = ident         { 如果符号是标识符 }
      then begin
             enter(variable);{ 将变量类型登录到符号表中 }
             getsym          { 单符号先行 }
           end
      else error(4)          { 读到的不是标识符 var后期望一个标识符 }
    end; { vardeclaration }
  
  { 列出p-code指令清单 }  
  procedure listcode;  
    var i : integer;
    { 从指令存储的起始下标cx0到终止下标cx-1 }
    { 循环输出 指令下标 指令码 嵌套层深度 偏移量 }
    begin
      for i := cx0 to cx-1 do  
        with code[i] do 
          writeln( i:4, mnemonic[f]:7,l:3, a:5)
    end; { listcode 子程序结束 }
   
  { 语句处理子程序 传入参数为符号集 fsys } 
  { 符号集fsys是可以不断扩充的 }
  procedure statement( fsys : symset );
    var i,cx1,cx2: integer;
    { 表达式处理子程序 }
    procedure expression( fsys: symset); 
      var addop : symbol;
      { 项处理子程序 }
      procedure term( fsys : symset);  
        var mulop: symbol ;
        { 因子处理子程序 }
        procedure factor( fsys : symset );
          var i : integer;
          begin
            test( facbegsys, fsys, 24 ); 
            { 进行test 检查是否语法成分合法后继符号 }
            { 合法符号集 因子首符号集，终止符号集 fsys，错误码 24表达式不能以此开始 }
            while sym in facbegsys do
              begin
                if sym = ident   { 当前符号为标识符 }
                then begin
                       i := position(id);  { 查刚读到符号在符号表中的位置 }
                       if i= 0
                       then error(11)      { 未查到 标识符未说明错误 11 }
                       else
                         with table[i] do  { 如在符号表中查到该id }
                           case kind of    { 则根据符号表中该项的kind决定后续操作 }
                             constant : gen(lit,0,val); 
                             { 生成取常量的p-code }
                             variable : gen(lod,lev-level,adr);
                             { 生成取变量的p-code }
                             prosedure: error(21)  { 表达式内不能有过程 21}
                           end;
                       getsym { 单符号先行 }
                     end
                else if sym = number { 数字处理 }
                     then begin
                            if num > amax
                            then begin
                                   error(30); { 数字超大错误 30 }
                                   num := 0   { 数字清零 }
                                 end;
                            gen(lit,0,num);  { 取数字常数 }
                            getsym           { 单符号先行 }
                          end
                     else if sym = lparen    { 是左括号 }
                          then begin
                                 getsym;
                                 expression([rparen]+fsys);
                                 { 调用表达式处理程序 把右括号加入符号集fsys }
                                 if sym = rparen
                                 then getsym { 读到右括号预读下一符号并退出 }
                                 else error(22) { 漏右括号错误 22 }
                               end;
                test(fsys,[lparen],23) 
                { factor出口检查 合法符号集fsys 终止符号集左括号 因子后不可为此符号 23 }
              end
          end; { factor 子程序结束 }
        begin { procedure term( fsys : symset);   
                var mulop: symbol ;    }
          factor( fsys+[times,slash]);
          while sym in [times,slash] do
            begin
              mulop := sym;
              getsym;
              factor( fsys+[times,slash] );
              if mulop = times
              then gen( opr,0,4 )
              else gen( opr,0,5)
            end
        end; { term }
      begin { procedure expression( fsys: symset);  
              var addop : symbol; }
        if sym in [plus, minus]
        then begin
               addop := sym;
               getsym;
               term( fsys+[plus,minus]);
               if addop = minus
               then gen(opr,0,1)
             end
        else term( fsys+[plus,minus]);
        while sym in [plus,minus] do
          begin
            addop := sym;
            getsym;
            term( fsys+[plus,minus] );
            if addop = plus
            then gen( opr,0,2)
            else gen( opr,0,3)
          end
      end; { expression }
      
    procedure condition( fsys : symset ); 
      var relop : symbol;
      begin
        if sym = oddsym
        then begin
               getsym;
               expression(fsys);
               gen(opr,0,6)
             end
        else begin
               expression( [eql,neq,lss,gtr,leq,geq]+fsys);
               if not( sym in [eql,neq,lss,leq,gtr,geq])
               then error(20)
               else begin
                      relop := sym;
                      getsym;
                      expression(fsys);
                      case relop of
                        eql : gen(opr,0,8);
                        neq : gen(opr,0,9);
                        lss : gen(opr,0,10);
                        geq : gen(opr,0,11);
                        gtr : gen(opr,0,12);
                        leq : gen(opr,0,13);
                      end
                    end
             end
      end; { condition }
    begin { procedure statement( fsys : symset );  
            var i,cx1,cx2: integer; }
      if sym = ident
      then begin
             i := position(id);
             if i= 0
             then error(11)
             else if table[i].kind <> variable
                  then begin { giving value to non-variation }
                         error(12);
                         i := 0
                       end;
             getsym;
             if sym = becomes
             then getsym
             else error(13);
             expression(fsys);
             if i <> 0
             then
               with table[i] do
                 gen(sto,lev-level,adr)
           end
      else if sym = callsym
      then begin
             getsym;
             if sym <> ident
             then error(14)
             else begin
                    i := position(id);
                    if i = 0
                    then error(11)
                    else
                      with table[i] do
                        if kind = prosedure
                        then gen(cal,lev-level,adr)
                        else error(15);
                    getsym
                  end
           end
      else if sym = ifsym
           then begin
                  getsym;
                  condition([thensym,dosym]+fsys);
                  if sym = thensym
                  then getsym
                  else error(16);
                  cx1 := cx;
                  gen(jpc,0,0);
                  statement(fsys);
                  code[cx1].a := cx
                end
           else if sym = beginsym
                then begin
                       getsym;
                       statement([semicolon,endsym]+fsys);
                       while sym in ([semicolon]+statbegsys) do
                         begin
                           if sym = semicolon
                           then getsym
                           else error(10);
                           statement([semicolon,endsym]+fsys)
                         end;
                       if sym = endsym
                       then getsym
                       else error(17)
                     end
                else if sym = whilesym
                     then begin
                            cx1 := cx;
                            getsym;
                            condition([dosym]+fsys);
                            cx2 := cx;
                            gen(jpc,0,0);
                            if sym = dosym
                            then getsym
                            else error(18);
                            statement(fsys);
                            gen(jmp,0,cx1);
                            code[cx2].a := cx
                          end
                     else if sym = readsym
                          then begin
                                 getsym;
                                 if sym = lparen
                                 then
                                   repeat
                                     getsym;
                                     if sym = ident
                                     then begin
                                            i := position(id);
                                            if i = 0
                                            then error(11)
                                            else if table[i].kind <> variable
                                                 then begin
                                                        error(12);
                                                        i := 0
                                                      end
                                                 else with table[i] do
                                                        gen(red,lev-level,adr)
                                          end
                                     else error(4);
                                     getsym;
                                   until sym <> comma
                                 else error(40);
                                 if sym <> rparen
                                 then error(22);
                                 getsym
                               end
                          else if sym = writesym
                               then begin
                                      getsym;
                                      if sym = lparen
                                      then begin
                                             repeat
                                               getsym;
                                               expression([rparen,comma]+fsys);
                                               gen(wrt,0,0);
                                             until sym <> comma;
                                             if sym <> rparen
                                             then error(22);
                                             getsym
                                           end
                                      else error(40)
                                    end;
      test(fsys,[],19)
    end; { statement }
  begin  {   procedure block( lev,tx : integer; fsys : symset );    
                var  dx : integer;  /* data allocation index */
                     tx0: integer;  /*initial table index */
                     cx0: integer;  /* initial code index */              }
    dx := 3;
    tx0 := tx;
    table[tx].adr := cx;
    gen(jmp,0,0); { jump from declaration part to statement part }
    if lev > levmax
    then error(32);

    repeat
      if sym = constsym
      then begin
             getsym;
             repeat
               constdeclaration;
               while sym = comma do
                 begin
                   getsym;
                   constdeclaration
                 end;
               if sym = semicolon
               then getsym
               else error(5)
             until sym <> ident
           end;
      if sym = varsym
      then begin
             getsym;
             repeat
               vardeclaration;
               while sym = comma do
                 begin
                   getsym;
                   vardeclaration
                 end;
               if sym = semicolon
               then getsym
               else error(5)
             until sym <> ident;
           end;
      while sym = procsym do
        begin
          getsym;
          if sym = ident
          then begin
                 enter(prosedure);
                 getsym
               end
          else error(4);
          if sym = semicolon
          then getsym
          else error(5);
          block(lev+1,tx,[semicolon]+fsys);
          if sym = semicolon
          then begin
                 getsym;
                 test( statbegsys+[ident,procsym],fsys,6)
               end
          else error(5)
        end;
      test( statbegsys+[ident],declbegsys,7)
    until not ( sym in declbegsys );
    code[table[tx0].adr].a := cx;  { back enter statement code's start adr. }
    with table[tx0] do
      begin
        adr := cx; { code's start address }
      end;
    cx0 := cx;
    gen(int,0,dx); { topstack point to operation area }
    statement( [semicolon,endsym]+fsys);
    gen(opr,0,0); { return }
    test( fsys, [],8 );
    listcode;
  end { block };
  
procedure interpret;  
  const stacksize = 500;
  var p,b,t: integer; { program-,base-,topstack-register }
      i : instruction;{ instruction register }
      s : array[1..stacksize] of integer; { data store }
  function base( l : integer ): integer;
    var b1 : integer;
    begin { find base l levels down }
      b1 := b;
      while l > 0 do
        begin
          b1 := s[b1];
          l := l-1
        end;
      base := b1
    end; { base }
  begin  
    writeln( 'START PL/0' );
    t := 0;
    b := 1;
    p := 0;
    s[1] := 0;
    s[2] := 0;
    s[3] := 0;
    repeat
      i := code[p];
      p := p+1;
      with i do
        case f of
          lit : begin
                  t := t+1;
                  s[t]:= a;
                end;
          opr : case a of { operator }
                  0 : begin { return }
                        t := b-1;
                        p := s[t+3];
                        b := s[t+2];
                      end;
                  1 : s[t] := -s[t];
                  2 : begin
                        t := t-1;
                        s[t] := s[t]+s[t+1]
                      end;
                  3 : begin
                        t := t-1;
                        s[t] := s[t]-s[t+1]
                      end;
                  4 : begin
                        t := t-1;
                        s[t] := s[t]*s[t+1]
                      end;
                  5 : begin
                        t := t-1;
                        s[t] := s[t]div s[t+1]
                      end;
                  6 : s[t] := ord(odd(s[t]));
                  8 : begin
                        t := t-1;
                        s[t] := ord(s[t]=s[t+1])
                      end;
                  9 : begin
                        t := t-1;
                        s[t] := ord(s[t]<>s[t+1])
                      end;
                  10: begin
                        t := t-1;
                        s[t] := ord(s[t]< s[t+1])
                      end;
                  11: begin
                        t := t-1;
                        s[t] := ord(s[t] >= s[t+1])
                      end;
                  12: begin
                        t := t-1;
                        s[t] := ord(s[t] > s[t+1])
                      end;
                  13: begin
                        t := t-1;
                        s[t] := ord(s[t] <= s[t+1])
                      end;
                end;
          lod : begin
                  t := t+1;
                  s[t] := s[base(l)+a]
                end;
          sto : begin
                  s[base(l)+a] := s[t];  { writeln(s[t]); }
                  t := t-1
                end;
          cal : begin  { generate new block mark }
                  s[t+1] := base(l);
                  s[t+2] := b;
                  s[t+3] := p;
                  b := t+1;
                  p := a;
                end;
          int : t := t+a;
          jmp : p := a;
          jpc : begin
                  if s[t] = 0
                  then p := a;
                  t := t-1;
                end;
          red : begin
                  writeln('??:');
                  readln(s[base(l)+a]);
                end;
          wrt : begin
                  writeln(s[t]);
                  t := t+1
                end
        end { with,case }
    until p = 0;
    writeln('END PL/0');
  end; { interpret }

begin { main 函数入口 ，主程序开始}
  writeln('please input source program file name : ');
  readln(sfile); {读}
  assign(fin,sfile);
  reset(fin);
  for ch := 'A' to ';' do
    ssym[ch] := nul;
  word[1] := 'begin        '; word[2] := 'call         ';
  word[3] := 'const        '; word[4] := 'do           ';
  word[5] := 'end          '; word[6] := 'if           ';
  word[7] := 'odd          '; word[8] := 'procedure    ';
  word[9] := 'read         '; word[10]:= 'then         ';
  word[11]:= 'var          '; word[12]:= 'while        ';
  word[13]:= 'write        ';
  
  wsym[1] := beginsym;      wsym[2] := callsym;
  wsym[3] := constsym;      wsym[4] := dosym;
  wsym[5] := endsym;        wsym[6] := ifsym;
  wsym[7] := oddsym;        wsym[8] := procsym;
  wsym[9] := readsym;       wsym[10]:= thensym;
  wsym[11]:= varsym;        wsym[12]:= whilesym;
  wsym[13]:= writesym;
  
  ssym['+'] := plus;        ssym['-'] := minus;
  ssym['*'] := times;       ssym['/'] := slash;
  ssym['('] := lparen;      ssym[')'] := rparen;
  ssym['='] := eql;         ssym[','] := comma;
  ssym['.'] := period;
  ssym['<'] := lss;         ssym['>'] := gtr;
  ssym[';'] := semicolon;
  
  mnemonic[lit] := 'LIT  '; mnemonic[opr] := 'OPR  ';
  mnemonic[lod] := 'LOD  '; mnemonic[sto] := 'STO  ';
  mnemonic[cal] := 'CAL  '; mnemonic[int] := 'INT  ';
  mnemonic[jmp] := 'JMP  '; mnemonic[jpc] := 'JPC  ';
  mnemonic[red] := 'RED  '; mnemonic[wrt] := 'WRT  ';
  
  declbegsys := [ constsym, varsym, procsym ];         { 声明语句块首符号集 }
  statbegsys := [ beginsym, callsym, ifsym, whilesym]; { 语句首符号集 }
  { ？ statbegsys为啥没有ident,readsym,writesym ？ }
  facbegsys := [ ident, number, lparen ]; { 因子首符号集 }
  err := 0;
  cc := 0;
  cx := 0;
  ll := 0;
  ch := ' ';
  kk := al;
  getsym;
  block( 0,0,[period]+declbegsys+statbegsys );
  if sym <> period
  then error(9);
  if err = 0
  then interpret
  else write('ERRORS IN PL/0 PROGRAM');
  writeln;
  close(fin)
end.  
 